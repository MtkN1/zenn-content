{
  "title": "仮想通貨 bot を色々なクラウドサービスに自動デプロイしてみる",
  "closed": false,
  "archived": false,
  "created_at": "2023-06-13",
  "comments": [
    {
      "author": "mtkn1",
      "created_at": "2023-06-13",
      "body_markdown": "仮想通貨 botter 界隈ではあまり語られない DevOps を自動デプロイだけやってみる。 クラウド VM に SSH で接続して bot を実行するようなレガシーな運用方法から抜け出す。\n\nもし全体的にまとまったら Zenn 本でも出したい。\n\n**前提条件**\n\n1. クラウドサービスのアカウントを持っていて VM などのリソースを作成できる。\n1. Git の知識がある。\n1. Docker の知識がある。\n\nこのスクラップでは以下を目標にする。\n\n**自動デプロイ**\n\n- GitHub Actions による CI/CD を利用して以下のデプロイ基盤に bot を自動デプロイできる設定を行う。\n\n**デプロイ基盤**\n\n- [x]: クラウド VM (Docker エンジン)\n    - AWS EC2\n    - Google Compute Engine\n- []: クラウド関数 / バッチ Job\n    - AWS Lambda\n    - Google Cloud Functions\n    - Google Cloud Run Jobs\n- []: AWS ECS\n- []: Kubernetes\n    - Google Kubernetes Engine (GKE)\n\n**ここでは目標としないが有用そうなソリューション**\n\n- HashiCorp Nomad\n- Docker Swarm\n\n**テンプレートリポジトリ**\n\nここのコードはこの GitHub リポジトリにまとまっている (作業中) 。 Compose 化したサンプル bot が main ブランチ、それをデプロイするワークフローファイルがそれぞれのサービスに対応する名称のブランチに上がっている。\n\nhttps://github.com/MtkN1/cloud-bot-deploy-template",
      "body_updated_at": "2023-06-15"
    },
    {
      "author": "mtkn1",
      "created_at": "2023-06-15",
      "body_markdown": "# クラウド VM (Docker エンジン)\n\nDocker CLI はローカルの Docker エンジンを操作するのが一般的だが、実は `-H` オプションや `context` を利用すると別のマシンの Docker エンジンを操作できる。 これを利用して CI/CD からクラウド VM へコンテナをビルド・デプロイする。\n\nDevOps 的には認証情報が SSH 鍵に紐づいておりレガシーな方法ではあるが、ややこしいクラウドのサービスを使わなくても良くてシンプルに VM インスタンス 1 つで済むので botter 向けな方法の 1 つだと思う。\n\n## 事前準備\n\n1. クラウドサービスのコンソールから VM のインスタンスを建て、 Docker をセットアップする。 SSH の鍵は予めクラウドサービスに登録しておく。\n    - AWS EC2\n        - イメージはデフォルトの *Amazon Linux 2023* がおすすめ。 Docker のインストールが簡単。\n        - (参考) コマンドでインスタンスを作成する場合。 **`--key-name` オプションは AWS に登録したキーペアの名前に修正する**。 CloudShell で実行する。\n            ```bash :CloudShell\n            aws ec2 run-instances --image-id $(aws ssm get-parameter --name /aws/service/ami-amazon-linux-latest/al2023-ami-kernel-6.1-x86_64 --query Parameter.Value --output text) --instance-type t2.micro --key-name <id_rsa>\n            ```\n        - (参考) Docker インストールコマンド。 SSH 接続して実行する。\n            ```bash :Remote machine\n            sudo dnf -y install docker && sudo systemctl enable --now docker && sudo usermod -aG docker ec2-user\n            ```\n    - Google Compute Engine\n        - イメージは *Container-Optimized OS* を選択するのがおすすめ。 コンテナしか動かない代わりに、 Docker が最初からセットアップされている。\n        - (参考) コマンドでインスタンスを作成する場合。 Cloud Shell で実行する。\n            ```bash :Cloud Shell\n            gcloud compute instances create instance-$(cat /dev/random | LC_ALL=C tr -dc \"[:alpha:]\" | tr '[:upper:]' '[:lower:]' | head -c 10) --image-family=cos-stable --image-project=cos-cloud --machine-type=e2-micro --scopes=https://www.googleapis.com/auth/cloud-platform\n            ```\n1. SSH 接続可能なことをテストする。\n    ```bash :Local machine\n    ssh -T user@ip-address hostname\n    ```\n1. SSH 接続を介して Docker エンジンが利用できることをテストする。\n    ```bash :Local machine\n    docker -H ssh://user@ip-address run --rm hello-world\n    ```\n1. GitHub に空のリポジトリを作成する。 README.md を作るにチェックをしておくとあとで楽にクローンできる。\n1. 作成したリポジトリに GitHub Actions 用の Secrets を登録する。 *Settings -> Secrets and variables -> Actions -> New repository secret*\n    - `DOCKER_HOST`\n        - *ssh://* + SSH 文字列\n            ```\n            ssh://user@ip-address\n            ```\n    - `SSH_CERT`\n        - クライアント側に保存されている SSH サーバーの公開鍵 (*known_hosts*) 。 以下のコマンドで取得できる。\n            ```bash :Local machine\n            grep <ip-address> ~/.ssh/known_hosts\n            ```\n    - `SSH_KEY`\n        - SSH クライアントの秘密鍵。 以下のコマンドで取得できる (※ RSA 認証でない場合はファイル名を変更する) 。\n            ```bash :Local machine (RSA)\n            cat ~/.ssh/id_rsa\n            ```\n\n## Docker Compose アプリとして bot を実装する\n\n作成したリポジトリをローカルマシンにクローンしてきて、Docker Compose で実行できる bot を作成してコミットする。\n\n:::message\nいきなり Compose アプリ用 bot を作成するのは面倒だと思うので、取り敢えずこのコマンドを実行すればテンプレートリポジトリから Compose アプリとして実行できるサンプル bot を現在のディレクトリにダウンロードできる。\n\n```bash :Local machine\ncurl -fsSL https://github.com/MtkN1/cloud-bot-deploy-template/archive/refs/heads/main.tar.gz | tar -xz --strip-components=1\n```\n:::\n\n## GitHub Actions ワークフロー\n\n以上の設定が完了して、次の YAML を GitHub Actions ワークフローファイル `.github/workflows/ssh.yml` としてコミットする。\n\n```yaml :.github/workflows/ssh.yml\nname: Docker Compose Deploy\n\non: push\n\njobs:\n  depoy:\n    runs-on: ubuntu-latest\n\n    steps:\n      - uses: actions/checkout@v3\n\n      - uses: ArwynFr/actions-docker-context@v2\n        with:\n          docker_host: ${{ secrets.DOCKER_HOST }}\n          context_name: remote\n          use_context: true\n          ssh_cert: ${{ secrets.SSH_CERT }}\n          ssh_key: ${{ secrets.SSH_KEY }}\n\n      - name: Docker Compose Up\n        run: docker compose up --build -d\n```\n\nこのワークフローファイルがコミットされると、それ以降はリポジトリにコミットが走るとごとに Compose アプリが Secrets に登録されている SSH ホストに対してデプロイされる。 デプロイのログは GitHub リポジトリの Actions タブから確認できる。\n\n:::message\nテンプレートリポジトリのサンプル bot を持ってきた場合は、常駐型と関数型の 2 つの bot が入っているのでクラウド VM 向きではない関数型までデプロイされてしまう。 常駐型のみデプロイする場合ワークフローの `run` 命令を `docker compose up --build -d monolithic_bot`をすれば常駐型のみデプロイされる。\n:::\n\n### ワークフロー解説\n\nジョブの 2 ステップ目で *ArwynFr/actions-docker-context* というアクションを利用して SSH ホストのコンテキストを作成している。これはポピュラーなアクションではない (現在 9 Star) が、 Docker CLI のコンテキスト機能を簡単に利用できるようにするアクションになっている。 作成したコンテキストを使った `docker compose up --build -d` コマンドによって SSH ホストの Docker エンジンでイメージがビルドされコンテナが起動され bot がデプロイされる仕組みになっている。\n\n他にある *wshihadeh/docker-deployment-action* アクションの方が最もポピュラー (現在 116 Star) のようだが、このアクションは Docker Compose v1 に依存しているようなので、自ら Docker Compose コマンドを打てるコンテキストの方を採用した。\n\n## 運用について (Portainer)\n\nこのスクラップは CI/CD で bot をデプロイできるようにする解説する目的だけれど、このクラウド VM に関してはおすすめの運用方法も補足する。\n\nセルフマネージドの Docker エンジンだけの素の状態だと、**bot (コンテナ) の手動停止や状態監視などの運用面がとても面倒** (結局 SSH になる) といった課題がある。 他に挙げたデプロイ基盤ではサービス専用のコンソールがあってデプロイしたコンテナや関数が管理できるが、セルフマネージドだとそれがない。 そこで **Portainer**（読み方：ポーテナー）といったサードパーティのコンテナ管理ツールを導入して運用するのがおすすめ。\n\n> Portainer Web UI (参考画像)\n![](https://docs.tutor.overhang.io/_images/portainer.png)\n\n- コンテナの状況やリソース使用率が確認できる。\n- コンテナの停止・再開ができる。\n- 標準出力に吐いているログを確認できる。\n\n### Portainer デプロイ手順\n\n1. トンネルを開いた状態で SSH 接続する。\n    ```bash :Local machine\n    ssh -L 9443:localhost:9443 user@ip-address\n    ```\n1. SSH 接続先で以下コマンドを実行して Portainer コンテナを起動する。\n    ```bash :Remote machine\n    docker volume create portainer_data && docker run -d -p 8000:8000 -p 9443:9443 --name portainer --restart=always -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer-ce:latest\n    ```\n1. Web ブラウザで https://localhost:9443 を開いて Portainer Web UI を開いて管理者ユーザーのパスワードを設定する。\n    - 補足: 初回の管理者ユーザー作成の為にファイアウォールを開けずに SSH トンネル経由で Portainer を開いている。\n1. クラウドサービスのコンソールから VM インスタンスに紐づくネットワーク設定でポート 9443 を開放する。\n1. クラウドで VM に静的 IP アドレスを割り振る。\n1. https://\\<static-ip-address\\>:9443 を開いてログインすると、外部からコンテナを管理できるようになる。\n1. (Optional) ロードバランサー等を設定すると SSL で怒られずにアクセスできるようになり、ブラウザのパスワード保存も効くはず。 ここでは省略する。",
      "body_updated_at": "2023-06-15"
    }
  ]
}